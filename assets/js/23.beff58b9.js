(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{530:function(a,r,e){"use strict";e.r(r);var s=e(6),t=Object(s.a)({},(function(){var a=this,r=a.$createElement,e=a._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"垃圾收集算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法"}},[a._v("#")]),a._v(" 垃圾收集算法")]),a._v(" "),e("h3",{attrs:{id:"复制收集算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复制收集算法"}},[a._v("#")]),a._v(" 复制收集算法")]),a._v(" "),e("p",[a._v("它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对\n内存区间的一半进行回收。\n![0001](/blog/java/gc/gc0001.png =600x500)")]),a._v(" "),e("h3",{attrs:{id:"标记清楚算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标记清楚算法"}},[a._v("#")]),a._v(" 标记清楚算法")]),a._v(" "),e("p",[a._v("标记存活的对象， 统一回收所有未被标记的对象(一般选择这种);也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。")]),a._v(" "),e("p",[a._v("![0002](/blog/java/gc/gc0002.png =600x500)")]),a._v(" "),e("h3",{attrs:{id:"标记整理算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标记整理算法"}},[a._v("#")]),a._v(" 标记整理算法")]),a._v(" "),e("p",[a._v("根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n![0003](/blog/java/gc/gc0003.png =600x500)")]),a._v(" "),e("h2",{attrs:{id:"垃圾收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[a._v("#")]),a._v(" 垃圾收集器")]),a._v(" "),e("h3",{attrs:{id:"serial收集器-xx-useserialgc-xx-useserialoldgc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serial收集器-xx-useserialgc-xx-useserialoldgc"}},[a._v("#")]),a._v(" Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)")]),a._v(" "),e("p",[a._v("串行收集器。这是一个单线程的垃圾收集器，垃圾收集的时候进行STW，新生代采用复收集算法，老年代采用标记整理算法。\nSerial Old收集器是Serial收集器的老年代版本。")]),a._v(" "),e("h3",{attrs:{id:"parallel-scavenge收集器-xx-useparallelgc-年轻代-xx-useparalleloldgc-老年代"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parallel-scavenge收集器-xx-useparallelgc-年轻代-xx-useparalleloldgc-老年代"}},[a._v("#")]),a._v(" Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))")]),a._v(" "),e("p",[a._v("可以理解为Serial收集器的多线程版本。我们可以简单理解和串行收集器没有什么大差别，只不过在垃圾收集到过程中，由单线程改为了多线程。\nParallel Old收集器是Parallel Scavenge收集器的老年代版本。")]),a._v(" "),e("h3",{attrs:{id:"parnew收集器-xx-useparnewgc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parnew收集器-xx-useparnewgc"}},[a._v("#")]),a._v(" ParNew收集器(-XX:+UseParNewGC)")]),a._v(" "),e("p",[a._v("ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。 新生代采用复制算法，老年代采用标记-整理算法。运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。")]),a._v(" "),e("h3",{attrs:{id:"cms收集器-xx-useconcmarksweepgc-old"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cms收集器-xx-useconcmarksweepgc-old"}},[a._v("#")]),a._v(" CMS收集器(-XX:+UseConcMarkSweepGC(old))")]),a._v(" "),e("p",[a._v("CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程 (基本上)同时工作。是通过标记清除算发实现的。")]),a._v(" "),e("ol",[e("li",[a._v("初始标记: 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。")]),a._v(" "),e("li",[a._v("并发标记: 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。")]),a._v(" "),e("li",[a._v("重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法做重新标记。")]),a._v(" "),e("li",[a._v("并发清理: 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理")]),a._v(" "),e("li",[a._v("并发重置: 重置本次GC过程中的标记数据。")])]),a._v(" "),e("h4",{attrs:{id:"三色标记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三色标记"}},[a._v("#")]),a._v(" 三色标记")]),a._v(" "),e("blockquote",[e("p",[a._v("在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。 这里我们引入“三色标记”来给大家解释下，把Gcroots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以 下三种颜色:")]),a._v(" "),e("ul",[e("li",[a._v("黑色: 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描 过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接(不经过 灰色对象) 指向某个白色对象。")]),a._v(" "),e("li",[a._v("灰色: 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。")]),a._v(" "),e("li",[a._v("白色: 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若 在分析结束的阶段， 仍然是白色的对象， 即代表不可达。")])])]),a._v(" "),e("h4",{attrs:{id:"浮动垃圾-多标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浮动垃圾-多标"}},[a._v("#")]),a._v(" 浮动垃圾（多标）")]),a._v(" "),e("p",[a._v("在并发标记的过程中，一些gc root被销毁，也就是说，一些标记为非垃圾的对象变成了垃圾，这些本轮GC不会清楚，就是浮动垃圾")]),a._v(" "),e("h4",{attrs:{id:"增量更新-漏标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#增量更新-漏标"}},[a._v("#")]),a._v(" 增量更新（漏标）")]),a._v(" "),e("p",[a._v("标记为黑色的对象，一旦新插入了指向白色对象的引用之后，把这个新插入的引用记下来，等并发标记结束之后，以这些黑色对象为gc root再次扫描一次。也就是说，黑色对象插入了指向白色对象的引用后，就变成灰色对象了。")]),a._v(" "),e("h4",{attrs:{id:"原始快照-漏标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原始快照-漏标"}},[a._v("#")]),a._v(" 原始快照（漏标）")]),a._v(" "),e("p",[a._v("当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用记下来，在并发标记结束后，以灰色对象为gc root重新扫描一次，如果扫描到白色对象就将其标为黑色，在这一轮gc中存活。")]),a._v(" "),e("h3",{attrs:{id:"g1收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#g1收集器"}},[a._v("#")]),a._v(" G1收集器")]),a._v(" "),e("p",[a._v("G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC 停顿时间要求的同时,还具备高吞吐量性能特征。\nG1虽然区分了年轻代和老年代，但是是非物理隔阂。是可以不连续的Region的集合。其分类Eden，Survivor，Old和其他的收集器没有不同。而对于大对象，专门有一个区域叫做Humongous区。判定的依据是如果一个对象超过了Region的50%，就放入大对象区域。")]),a._v(" "),e("ol",[e("li",[a._v("初始标记(initial mark，STW):暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ;")]),a._v(" "),e("li",[a._v("并发标记(Concurrent Marking):同CMS的并发标记")]),a._v(" "),e("li",[a._v("最终标记(Remark，STW):同CMS的重新标记")]),a._v(" "),e("li",[a._v("筛选回收(Cleanup，STW):筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划。\n所谓回收计划，根据我们指定的回收时间，回收器会维护一个有限列表，有限回收回收价值较大的Region。而指定这个GC听懂时间，200ms左右是一个比较合理的值。")])]),a._v(" "),e("h4",{attrs:{id:"g1的使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#g1的使用场景"}},[a._v("#")]),a._v(" G1的使用场景")]),a._v(" "),e("ul",[e("li",[a._v("50%以上的堆被存活对象占用")]),a._v(" "),e("li",[a._v("对象分配和晋升的速度变化非常大")]),a._v(" "),e("li",[a._v("垃圾回收时间特别长，超过1秒")]),a._v(" "),e("li",[a._v("8GB以上的堆内存(建议值)")]),a._v(" "),e("li",[a._v("停顿时间是500ms以内")])]),a._v(" "),e("h3",{attrs:{id:"zgc收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zgc收集器"}},[a._v("#")]),a._v(" ZGC收集器")]),a._v(" "),e("p",[a._v("JDK11引入的具有实验性质的垃圾收集器，在现阶段不分年轻代和老年代，后续应该会调整。")]),a._v(" "),e("ul",[e("li",[a._v("支持TB量级的堆。")]),a._v(" "),e("li",[a._v("最大GC停顿时间不超10ms。")]),a._v(" "),e("li",[a._v("奠定未来GC特性的基础。")]),a._v(" "),e("li",[a._v("最糟糕的情况下吞吐量会降低15%。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。")])])])}),[],!1,null,null,null);r.default=t.exports}}]);